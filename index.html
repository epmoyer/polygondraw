<!doctype html>
<html lang="en"> <head> <meta charset="UTF-8">
    <title>PolygonDraw</title>

    <meta name="viewport" content="user-scalable=no" />
   <link href="https://netdna.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- GUI -->
<canvas></canvas>
<div class="wrapper">
    <form method="post">
      <div class="textarea-container">
        <textarea name="coords"></textarea>
        <textarea name="frames" class="invisible">sup</textarea>
      </div>
      <input type="range" id="speed" name="speed" min="100" max="1000" value="500" title="animation playback speed">
      <input type="range" id="zoom" name="zoom" min="2" max="200" value="20" title="magnification">
      <input type="range" id="grid" name="grid" min="1" max="4" value="1" title="grid subdivision">
    </form>
    <ul style="top:10px;left:10px" class="tools">
      <li id="arrows" title="M: Move"><i class="fa fa-arrows"></i></li>
      <li id="pencil" title="L: Line"><i class="fa fa-pencil"></i></li>
      <li id="plus" title="A: Add"><i class="fa fa-plus"></i></li>
      <li id="scissors" title="C: Cut"><i class="fa fa-scissors"></i></li>
      <li id="crosshairs" title="O: Change Origin"><i class="fa fa-crosshairs"></i></li>
      <li id="eye-slash" title="V: Toggle Visibility"><i class="fa fa-eye-slash"></i></li>
      <li id="anchor" title="S: Toggle Grid Snap"><i class="fa fa-anchor"></i></li>
    </ul>

    <ul style="top:45px;left:10px;" class="tools">
      <li id="undo" title="U: Undo"><i class="fa fa-undo"></i></li>
      <li id="redo" title="R: Redo"><i class="fa fa-repeat"></i></li>
      <li id="refresh" title="Delete All"><i class="fa fa-trash-o"></i></li>
      <li id="hand" title="H: Hand"><i class="fa fa-hand-paper-o"></i></li>
      <li id="scale" title="X: Scale"><i class="fa fa-balance-scale"></i></li>
    </ul>

    <!-- <ol style="bottom:89px;left:10px;">
        <li><i class="fa fa-file fa-rotate-180"></i></li><li><i class="fa fa-trash-o"></i></li>
    </ol> -->

    <ul style="top:80px;left:10px;">
        <li id="color:1" style="background-color:#2020FF"><i class="fa fa-paint-brush" title="Color: BLUE"></i>
        <li id="color:2" style="background-color:#FFFFFF"><i class="fa fa-paint-brush" title="Color: WHITE"></i>
        <li id="color:3" style="background-color:#00FF00"><i class="fa fa-paint-brush" title="Color: GREEN"></i>
        <li id="color:4" style="background-color:#FFFF00"><i class="fa fa-paint-brush" title="Color: YELLOW"></i>
        <li id="color:5" style="background-color:#FF0000"><i class="fa fa-paint-brush" title="Color: RED"></i>
        <li id="color:6" style="background-color:#00FFFF"><i class="fa fa-paint-brush" title="Color: CYAN"></i>
        <li id="color:7" style="background-color:#FF00FF"><i class="fa fa-paint-brush" title="Color: MAGENTA"></i>
        <li id="color:8" style="background-color:#008080"><i class="fa fa-paint-brush" title="Color: CYAN_DK"></i>
    </ul>

    <ul style="top:115px;left:10px;">
        <li id="color:9"  style="background-color:#E55300"><i class="fa fa-paint-brush" title="Color: ORANGE"></i>
        <li id="color:10" style="background-color:#8B4513"><i class="fa fa-paint-brush" title="Color: BROWN"></i>
        <li id="color:11" style="background-color:#808000"><i class="fa fa-paint-brush" title="Color: YELLOW_DK"></i>
        <li id="color:12" style="background-color:#808080"><i class="fa fa-paint-brush" title="Color: GRAY"></i>
        <li id="color:13" style="background-color:#404040"><i class="fa fa-paint-brush" title="Color: GRAY_DK"></i>
        <li id="color:14" style="background-color:#87CEFA"><i class="fa fa-paint-brush" title="Color: LIGHTSKYBLUE"></i>
        <li id="color:15" style="background-color:#1E90FF"><i class="fa fa-paint-brush" title="Color: DODGERBLUE"></i>
        <li id="color:16" style="background-color:#ADD8E6"><i class="fa fa-paint-brush" title="Color: LIGHTBLUE"></i>
    </ul>

    <div class="visibility-controls" style="bottom:50px;right:0px">
        <input type="checkbox" id="prev-frame-visible" title="rotoscope reveal previous frame" />
        <input type="checkbox" id="next-frame-visible" title="rotoscope reveal next frame" />
    </div>

    <ul class="frame-controls" style="bottom:40px;right:20px">
      <li id="add-button" title="Add new frame with existing points"><i class="fa fa-plus"></i></li>
      <li id="delete-button" title="Delete current frame"><i class="fa fa-minus"></i></li>
      <li id="back-button" title="Previous frame"><i class="fa fa-backward"></i></li>
      <li id="next-button" title="Next frame"><i class="fa fa-forward"></i></li>
      <li id="play-button" title="Play animation"><i class="fa fa-play"></i></li>
      <li id="stop-button" title="Stop animation"><i class="fa fa-stop"></i></li>
        <li id="clipboard-button" title="Copy all frames to clipboard"><i class="fa fa-clipboard"></i></li>
    </ul>
</div>

<style>
img {
    display: block;
    position: absolute;
    opacity: 1;
    top: 25px;
    left: 10px;
    width: auto;
}
</style>

<!-- Insert Image Below -->
<!-- ================== -->

<!-- Code -->
<script>
(function() {

var VERSION = "3.4";

// Init GUI Components
var canvas = document.querySelector("canvas");
var div = document.querySelector("div");
var form = document.querySelector("form");
var text = form.coords;
var ctx = canvas.getContext("2d");
var speed = form.speed;
var gridDivision = form.grid;

// Global vars
var Tools = {
    MOVE: 0,
    LINE: 1,
    ADD: 2,
    CUT: 3,
    ORIGIN: 4,
    VISIBILITY: 5,
    COLORIZE: 6,
    HAND: 7,
};
var Styles = {
    ARRAY: 0,
    ONE_ARRAY: 1,
    NORMALIZED: 2,
    ONE_NORMALIZED: 3
};
var shapes, frame, grid, history, currentTool = Tools.LINE, mousePos={x:0,y:0}, snap_enabled=true;
var lastMovedPoint;

var HANDLE_RELATIVE_RADIUS = 0.17; // Vertex handle radius relative to grid spacing
var selectedHandleIndexes = [];
var tempVisibility = undefined;

var PEN_COMMAND = 9000;
var PEN_UP = 7000;
var PEN_COLOR0 = 8000;

var COLORS = [
    "#000000", // 00 (Penup)
    "#2020FF", // 01 BLUE
    "#FFFFFF", // 02 WHITE
    "#00FF00", // 03 GREEN
    "#FFFF00", // 04 YELLOW
    "#FF0000", // 05 RED
    "#00FFFF", // 06 CYAN
    "#FF00FF", // 07 MAGENTA
    "#008080", // 08 CYAN_DK
    "#E55300", // 09 ORANGE
    "#8B4513", // 10 BROWN
    "#808000", // 11 YELLOW_DK
    "#808080", // 12 GRAY
    "#404040", // 13 GRAY_DK
    "#87CEFA", // 14 LIGHTSKYBLUE
    "#1E90FF", // 15 DODGERBLUE
    "#ADD8E6", // 16 LIGHTBLUE
];

var current_selected_color = COLORS[1];
var DELIMITER = ',';

// Functions
function windowResize() {
    canvas.width = window.innerWidth - 359;
    canvas.height = window.innerHeight - 12;
    div.setAttribute("style", "height:" + canvas.height + "px");
    grid.set(parseInt(form.zoom.value));
    redraw();
}

function getPointArray() {
  var items = text.value.replace(/\s/g, '').split(DELIMITER);
  var output = [];
  for (var i = 0, length = items.length; i < length; i++) {
    var item = items[i];
    var number = parseFloat(item, 10);
    if (!isNaN(number)) output.push(number);
  }
  return output;
}

function getAllFrames(options) {
  var frames = [];
  for (var i = 0, length = shapes.length; i < length; i++) {
    var shape = shapes[i];
    frames.push(getFrameAtIndex(i, options));
  }
  if (frames.length === 1) frames = frames[0];
  return frames;
}

function getFrameAtIndex(index, options) {
  var modifier = (options || {}).modifier || 1;
  var shape = shapes[index];
  var points = [];
  for (var i = 0, len = shape.points.length; i < len; i++) {
    var point = shape.points[i];
    points.push(point.x * modifier);
    points.push(point.y * modifier);
    if (point.visible === false) {
      points.push(PEN_COMMAND);
      points.push(PEN_UP);
    }
  }
  return points;
}

function currentShape() {
  return shapes[frame];
}

var previousButton;
function setCurrentCanvasClass(canvasClass, element) {
  canvas.className = 'cursor-' + canvasClass;
  if (element) {
    if (previousButton) previousButton.className = '';
    element.className = 'active';
    previousButton = element;
  }
}

//---------------------------------
// Distance to line segment.
// Adapted from http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
function sqr(x) { return x * x; }
function pointDistanceSquared(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y); }
function pointDistance(v, w) { return Math.sqrt(sqr(v.x - w.x) + sqr(v.y - w.y)); }
function distanceToSegmentSquared(p, v, w) {
  var l2 = pointDistanceSquared(v, w);
  if (l2 === 0) return pointDistanceSquared(p, v);
  var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
  if (t < 0) return pointDistanceSquared(p, v);
  if (t > 1) return pointDistanceSquared(p, w);
  return pointDistanceSquared(p, { x: v.x + t * (w.x - v.x),
                                   y: v.y + t * (w.y - v.y) });
}
function distanceToSegment(p, v, w) { return Math.sqrt(distanceToSegmentSquared(p, v, w)); }
//---------------------------------

function formatCoordinate(coordinate){
    // Return shortest possible string representation, up to 2 digits of precision
    //   9.00  -> "9"
    //   9.10  -> "9.1"
    //   9.12  -> "9.12"
    //   9.123 -> "9.12"
    return Number(coordinate.toFixed(2)).toString();
}

function drawPoints() {
    var i, point;
    var output_items = [];
    var color_items, point_items;
    var shape = currentShape();

    for (i = 0; i < shape.points.length; i++) {
        point = shape.points[i];

        point_items = [formatCoordinate(point.x), formatCoordinate(point.y)];
        if(point.color){
            color_items = [PEN_COMMAND, PEN_COLOR0 + point.color];
        }
        else{
            color_items = [];
        }

        if (i === 0){
            output_items = output_items.concat(color_items);
            output_items = output_items.concat(point_items);
        }
        else{
            output_items = output_items.concat(point_items);
            output_items = output_items.concat(color_items);
        }

        if(!point.visible){
            output_items.push(PEN_COMMAND);
            output_items.push(PEN_UP);
        }
    }

    for (i = 0; i < output_items.length; i++) {
        output_items[i] = output_items[i].toString();
    }
}

function closestPoint(searchPoint) {
    // Returns null if there are 0 points in the shape
    var shape = currentShape();

    var len = shape.points.length;
    var shortestDistance = 10000000000;
    var matchIndex = null;

    // Find the nearest line segment to the click
    for (var i=0; i<len; i++){
        var distance = pointDistance(searchPoint, shape.points[i]);
        if(distance<=shortestDistance){
            shortestDistance = distance;
            matchIndex = i;
        }
    }
    return matchIndex;
}

function undo(){
    currentShape().points = history[frame].undo();
    redraw();
}

function redo(){
    currentShape().points = history[frame].redo();
    redraw();
}

function switchTool(newTool){
    currentTool = newTool;
    var shouldResetSelectedHandleIndexes = true;
    redraw();
    switch(currentTool){
        case Tools.MOVE:
          setCurrentCanvasClass('move', buttonArrows);
          break;
        case Tools.LINE:
          setCurrentCanvasClass('pencil', buttonPencil);
          break;
        case Tools.ADD:
          setCurrentCanvasClass('add', buttonPlus);
          break;
        case Tools.CUT:
          setCurrentCanvasClass('cut', buttonScissors);
          break;
        case Tools.ORIGIN:
          setCurrentCanvasClass('origin', buttonCrosshairs);
          break;
        case Tools.VISIBILITY:
          setCurrentCanvasClass('visibility', buttonEyeSlash);
          break;
        case Tools.HAND:
          shouldResetSelectedHandleIndexes = false;
          setCurrentCanvasClass('hand', buttonHand);
          break;
        case Tools.COLORIZE:
          if (previousButton) previousButton.className = '';
          previousButton = undefined;
          break;
    }
    if (shouldResetSelectedHandleIndexes) { selectedHandleIndexes = []; }
}

function redraw(){
    var x_pos = 10;
    var y_pos = 15;
    var y_step = 15;
    grid.draw();
    var previousFrame = shapes[frame - 1];
    var nextFrame = shapes[frame + 1];
    if (previousFrameVisible && previousFrame) {
      previousFrame.draw(grid, '#aa6666');
    }
    if (nextFrameVisible && nextFrame) {
      nextFrame.draw(grid, '#6666aa');
    }
    currentShape().draw(grid);
    drawPoints();

    ctx.save();
    ctx.font="12px Helvetica";

    // Show version
    ctx.fillStyle = "gray";
    ctx.fillText('PolygonDraw v' + VERSION, x_pos, y_pos);
    y_pos += y_step;

    // Show snap mode
    ctx.fillStyle = snap_enabled ? 'white' : 'red';
    ctx.fillText(snap_enabled ? 'Snap Enabled' : 'Snap Disabled', x_pos, y_pos);
    y_pos += y_step;

    // Show mouse coordinates
    ctx.fillStyle = "white";
    ctx.fillText("("+formatCoordinate(mousePos.x)+", "+formatCoordinate(mousePos.y)+")", x_pos, y_pos);
    y_pos += y_step;

    // Show current tool
    var modeText = "";

    switch(currentTool){
        case Tools.MOVE:
            modeText = "Move";
            break;
        case Tools.LINE:
            modeText = "Line";
            break;
        case Tools.ADD:
            modeText = "Add";
            break;
        case Tools.CUT:
            modeText = "Cut";
            break;
        case Tools.ORIGIN:
            modeText = "Change Origin";
            break;
        case Tools.VISIBILITY:
            modeText = "Toggle Visibility";
            break;
        case Tools.COLORIZE:
            modeText = "Colorize";
            break;
        case Tools.HAND:
            modeText = "Hand";
            break;
    }
    ctx.fillText(modeText, x_pos, y_pos);
    y_pos += y_step;
    var frameText = 'Frame ' + (frame + 1) + '/' + shapes.length;
    if (interval) frameText += ' (ANIMATING)';
    ctx.fillText(frameText, x_pos, y_pos);
    ctx.restore();
    text.value = getFrameAtIndex(frame).join(DELIMITER);
    y_pos += y_step;
    ctx.fillText('GRID LEVEL: ' + gridDivision.value, x_pos, y_pos);
    y_pos += y_step;
    ctx.fillText('PAN: (' + Math.floor(panX) + ', ' + Math.floor(panY) + ')', x_pos, y_pos);
}

// DataObjs
var Shape = function() {
  this.reset();
};

Shape.prototype = {
    reset: function() {
        this.points = [];

        // Can supply initial point data in URL following "?".
        // For example: wwww.mylocation.com/polygondraw.html?[0,0,1,1]
        var pointArray = getPointArray();
        var color_index = null;
        var pending_color = null;
        for(var i=0,len=pointArray.length; i<len; i+=2){
            if(pointArray[i]==PEN_COMMAND){
                if(pointArray[i+1]==PEN_UP){
                   this.points[this.points.length-1].visible = false;
                }
                else{
                    color_index = pointArray[i+1] - PEN_COLOR0;
                    if(color_index >=0 && color_index < COLORS.length){
                        if(i===0){
                            // If a color is specified as the very fist directive,
                            // then that color is applied to the next vertex (which
                            // will be the fist vertex in the data set).  Otherwise,
                            // color directives are applied to the previous vertex.
                            pending_color = color_index;
                        }
                        else{
                            this.points[this.points.length-1].color = color_index;
                        }
                    }
                }
            }
            else{
                this.points.push({
                    x:pointArray[i],
                    y:pointArray[i+1],
                    visible:true,
                    color: pending_color ? pending_color : null
                });
                pending_color = null;
            }
        }
        // Start in MOVE mode if starting with an existing dataset
        currentTool = Tools.MOVE;
    },

    addPointToEnd: function(position) {
        var last_point = this.getLastPoint();
        if (this.points.length > 0 &&
           (position.x === last_point.x &&
            position.y === last_point.y)
        ) {
            // No noting if the add location is the same as the last point
            return;
        }

        this.addPointAfterIndex(
            this.points.length - 1,
            position
            );
    },

    addPointAfterIndex: function(index, position){
        currentShape().points.splice(
            index + 1,
            0,
            {   x:position.x,
                y:position.y,
                visible:true,
                color:null
            });
        this._optimize();
    },

    getLastPoint: function() {
        if (this.points.length === 0){
            return null;
        }

        last_point = this.points[this.points.length-1];
        return {
            x: last_point.x,
            y: last_point.y
        };
    },


    deletePoint: function(index){
        this.points.splice(index, 1);
        this._optimize();
    },

    colorizePoint: function(index, color) {
        this.points[index].color = color;
        this._optimize();
    },

    _optimize: function() {
        // Optimize the color assignments.  Color only needs to be specified once, on
        // the first node that the color is drawn TO (not from)
        var i, point, color, points;
        color = null;
        points = [];
        for (i = 0; i < this.points.length; i++) {
            point = this.points[i];
            if ((color !== null) && (point.color == color)){
                point.color = null;
            }
            if (point.color !== null){
                color = point.color;
            }

            points.push(point.x);
            points.push(point.y);
        }

        text.value = points.join(DELIMITER);
    },

    draw: function(grid_, faintColor) {
        var i, p, color;

        ctx.save();

        // Draw lines
        if(this.points.length >= 2){
            if (faintColor) {
              line_color = faintColor;
            } else {
              if(this.points[0].color){
                  line_color = COLORS[this.points[0].color];
              }
              else{
                  line_color = 'white';
              }
            }
            ctx.strokeStyle = line_color;
            ctx.lineWidth=2;
            ctx.beginPath();
            for (i=0; i < this.points.length; i++) {
                p = grid_.toPoint(this.points[i]);
                if (i === 0) {
                    ctx.moveTo(p.x, p.y);
                    continue;
                }
                ctx.lineTo(p.x, p.y);
                ctx.stroke();

                if(p.color){
                    line_color=COLORS[p.color];
                }

                if(p.visible){
                    ctx.strokeStyle = line_color;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                }
                else{
                    ctx.strokeStyle = 'gray';
                    ctx.setLineDash([5, 10]);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                }
            }
            ctx.stroke();
        }

        // Draw vertex handles
        for (i = 0; i < this.points.length; i++) {
          if (selectedHandleIndexes.indexOf(i) !== -1) {
                color = 'red';
            }
            else if (i == this.points.length - 1){
                color = 'blue';
            }
            else if (i == 0){
                color = 'cyan';
            }
            else {
                color = 'green';
            }
            p = grid_.toPoint(this.points[i]);
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, HANDLE_RELATIVE_RADIUS * grid.size, 0, 2 * Math.PI, false);
            ctx.fill();
            ctx.stroke();
        }
        ctx.restore();
    },


};

var History = function(){
    this.clear();
};

History.prototype = {
    clear: function(){
        this.pointsHistory = [];
        this.tail = -1;
    },

    copy: function(history){
      this.tail = history.tail;
      this.pointsHistory = history.clone(history.pointsHistory);
    },

    commit: function(points){
      var pointsCanBeCommited = function(pointsA, pointsB) {
        if (pointsA.length !== pointsB.length) return true;
        for (var i = 0, length = pointsA.length; i < length; i++) {
          var pointA = pointsA[i];
          var pointB = pointsB[i];
          for (var key in pointA) {
            if (pointA.hasOwnProperty(key) && pointA[key] !== pointB[key]) return true;
          }
        }
        return false;
      }

      var lastPoints = this.pointsHistory[this.tail];
      if (lastPoints && !pointsCanBeCommited(points, lastPoints)) return;
      this.pointsHistory = this.pointsHistory.slice(0, this.tail + 1);
      this.pointsHistory.push(this.clone(points));
      this.tail = this.pointsHistory.length - 1;
    },

    undo: function(){
      if (this.tail >= 0) this.tail -= 1;
      return this.clone(this.pointsHistory[this.tail]);
    },

    redo: function(){
      if (this.tail < this.pointsHistory.length - 1) this.tail += 1;
      return this.clone(this.pointsHistory[this.tail]);
    },

    clone: function(points){
        if (!points) return [];
        var pointsClone = [];
        for(var i=0, len=points.length; i<len; i++){
            pointsClone.push({
                x:points[i].x,
                y:points[i].y,
                visible:points[i].visible,
                color:points[i].color
            });
        }
        return pointsClone;
    },
};

var Grid = function() {
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
};
Grid.prototype = {
    set: function(size) {
        this.size = Math.round(size * gridFraction);

        var wt = Math.ceil(canvas.width / size);
        var ht = Math.ceil(canvas.height / size);
        this.width = (wt + wt%2) * size + 1;
        this.height = (ht + ht%2) * size + 1;

        this.x = Math.round((canvas.width - this.width)/2);
        this.y = Math.round((canvas.height - this.height)/2);

        this.origo = {
            x: Math.round(this.width/(this.size*2)) + panX,
            y: Math.round(this.height/(this.size*2)) + panY,
        };

        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.createGrid();
        this.draw();
    },

    createGrid: function() {
        var x = 0.5,
            y = 0.5,
            w = this.width-1,
            h = this.height-1;

        this.ctx.save();
        this.ctx.strokeStyle = "#282828";
        this.ctx.fillStyle = "#000";
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.ctx.beginPath();
        this.ctx.rect(x, y, w, h);
        while (x < w) {
            x += this.size;
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(x, y+h);
        }
        x = 0.5;
        while (y < h) {
            y += this.size;
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(x+w, y);
        }
        this.ctx.stroke();

        this.ctx.beginPath();
        this.ctx.fillStyle = "#383838";
        this.ctx.arc(this.origo.x * this.size + 0.5, this.origo.y * this.size + 0.5, 5, 0, 2*Math.PI);
        this.ctx.fill();

        this.ctx.restore();
    },

    draw: function() {
        ctx.drawImage(this.canvas, this.x, this.y);
    },

    translate: function(x, y) {

        if(snap_enabled){
            // Snap to grid
            x = Math.round((x - this.x) / this.size);
            y = Math.round((y - this.y) / this.size);
        }
        else{
            // Free form
            x = (x - this.x) / this.size;
            y = (y - this.y) / this.size;
        }

        return {
            x: x - this.origo.x,
            y: y - this.origo.y
        };
    },

    toPoint: function(p) {
        return {
            x: (p.x + this.origo.x) * this.size + this.x + 0.5,
            y: (p.y + this.origo.y) * this.size + this.y + 0.5,
            visible: p.visible,
            color: p.color
        };
    }
};


// Setup
var gridFraction = 1 / parseInt(gridDivision.value);
var lastGridFraction = 1;
var drag = {
  active: false,
  x: 0,
  y: 0,
  panX: 0,
  panY: 0,
};
var panX = 0;
var panY = 0;
var mouseIsDown = false;
var previousFrameVisible = false;
var nextFrameVisible = false;

shapes = [new Shape()];
grid = new Grid();
history = [new History()];
frame = 0;

windowResize();
redraw();

window.onresize = windowResize;

text.onkeydown = function(evt) {
  if (evt.which === 13) {
    text.blur();
  }
}
text.onchange = function() {
  var points = text.value.replace(/[^\[\],\d\.-]/g, '');
  if (/\[/.test(points)) {
    var parsed;
    try {
      parsed = JSON.parse(points);
    } catch (error) {
      alert(error);
      return;
    }
    var frames;
    if (typeof(parsed[0]) === 'object') {
      frames = parsed;
    } else {
      frames = [parsed];
    }

    var currentFrame = frame;
    text.value = frames[0].join(DELIMITER);
    currentShape().reset();

    for (var i = 1, length = frames.length; i < length; i++) {
      frame += 1;
      text.value = frames[i].join(DELIMITER);
      shapes.push(new Shape());
      var newHistory = new History();
      newHistory.clear();
      newHistory.commit(currentShape().points);
      history.push(newHistory);
    }
    frame = currentFrame;

  } else {
    currentShape().reset();
  }

  history[frame].commit(currentShape().points);
  redraw();
};

form.zoom.oninput = function() {
    // Responds during slide Firefox, Safari, Chrome
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    grid.set(parseInt(this.value));
    redraw();
};

form.zoom.onchange = function() {
    // IE10 support (IE10 does not support oninput)
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    grid.set(parseInt(this.value));
    redraw();
};

window.onmouseup = function(evt) {
  drag.active = false;
  mouseIsDown = false;
  var shape = currentShape();
  if (currentTool === Tools.MOVE && lastMovedPoint) {
    var point = shape.points[selectedHandleIndexes[selectedHandleIndexes.length - 1]];
    if (point && (lastMovedPoint.x !== point.x || lastMovedPoint.y !== point.y)) {
      history[frame].commit(shape.points);
    }
  }
};

window.onmousedown = function(evt) {
    var x = evt.x - 5;
    var y = evt.y - 5;

    if (0 > x || canvas.width < x ||
        0 > y || canvas.height < y
    ) {
        return;
    }

    var click = grid.translate(x, y);
    var index, i, len;
    var shape = currentShape();
    mouseIsDown = true;
    switch(currentTool){
        case Tools.HAND:
            if (!drag.active) {
                drag.x = x;
                drag.y = y;
                drag.panX = panX;
                drag.panY = panY;
                drag.active = true;
            }
            break;
        case Tools.LINE:
            shape.addPointToEnd(click);
            history[frame].commit(shape.points);
            break;

        case Tools.MOVE:
            var selectedHandleIndex = indexForPoint(click);
            if (selectedHandleIndex === -1) {
              mouseIsDown = false;
              break;
            }
            var point = shape.points[selectedHandleIndex];
            lastMovedPoint = { x: point.x, y: point.y };
            var index = selectedHandleIndexes.indexOf(selectedHandleIndex);

            var isSelected = index !== -1;

            if (isSelected) {
              selectedHandleIndexes.splice(index, 1);
            } else if (!evt.shiftKey) {
              selectedHandleIndexes = [];
            }

            if (!isSelected || !evt.shiftKey) {
              selectedHandleIndexes.push(selectedHandleIndex);

              for (var i = 0, length = shape.points.length; i < length; i++) {
                var toCompare = shape.points[i];

                if (selectedHandleIndexes.indexOf(i) === -1 && point.x === toCompare.x && point.y === toCompare.y) {
                  selectedHandleIndexes.push(i);
                }
              }
            }
            break;

        case Tools.ADD:
            len = shape.points.length;
            var shortestDistance = 10000000000;
            var matchIndex = 0;
            if(len >= 2){
                // Find the nearest line segment to the click
                for (i=0; i<len-1; i++){
                    var distance = distanceToSegment(click, shape.points[i], shape.points[i+1]);
                    if(distance<shortestDistance){
                        shortestDistance = distance;
                        matchIndex = i;
                    }
                }
                // Add the new point
                shape.addPointAfterIndex(matchIndex, click);
                history[frame].commit(shape.points);
            }
            break;

        case Tools.CUT:
            var index = indexForPoint(click);
            if (index === -1) break;
            shape.deletePoint(index);
            history[frame].commit(shape.points);
            break;

        case Tools.ORIGIN:
            // Move the origin to the click location
            for (i=0, len = shape.points.length; i<len; i++){
              shape.points[i].x -= click.x;
              shape.points[i].y -= click.y;
            }
            history[frame].commit(shape.points);
            break;
        case Tools.VISIBILITY:
            // Toggle visibility of closest point
          if (tempVisibility && canSetVisibilityForIndex(tempVisibility.index, shape)) {
              clearTempVisibility(!tempVisibility.state);
              history[frame].commit(shape.points);
          }
          break;
        case Tools.COLORIZE:
            // Toggle visibility of closest point
            var index = indexForPoint(click);
            if (index === -1) break;
            shape.colorizePoint(index, current_selected_color);
            history[frame].commit(shape.points);
            break;
    }


    text.blur();
    redraw();
};

var canSetVisibilityForIndex = function(index, shape) {
  // First point may not be invisible
  // Two consecutive points may not be invisible
  // Last and next-to-last point may not be invisible
  return ((index>0 && shape.points[index-1].visible) &&
    !(shape.points.length-1>index && !shape.points[index+1].visible) &&
    (index < shape.points.length-2));
}

var indexForPoint = function(point) {
  var shape = currentShape();
  for (var i = 0, length = shape.points.length; i < length; i++) {
    var currentPoint = shape.points[i];
    if (currentPoint.x === point.x && currentPoint.y === point.y) return i;
  }
  return -1;
};

window.onmousemove = function(evt) {
    var x = evt.x - 5;
    var y = evt.y - 5;

    if (0 > x || canvas.width < x ||
        0 > y || canvas.height < y
    ) {
        return;
    }

    mousePos = grid.translate(x, y);
    redraw();
    var shape = currentShape();

    if (currentTool === Tools.LINE && shape.points.length > 0) {
        var c = grid.toPoint(shape.getLastPoint());

        ctx.setLineDash([]);
        ctx.strokeStyle = 'gray';
        ctx.beginPath();
        ctx.moveTo(c.x, c.y);
        ctx.lineTo(x, y);
        ctx.stroke();
    } else if (currentTool === Tools.MOVE && mouseIsDown && selectedHandleIndexes.length) {
      var index = selectedHandleIndexes.length - 1;
      var selectedHandleIndex = selectedHandleIndexes[index];
      var deltaX = mousePos.x - shape.points[selectedHandleIndex].x;
      var deltaY = mousePos.y - shape.points[selectedHandleIndex].y;
      shape.points[selectedHandleIndex].x = mousePos.x;
      shape.points[selectedHandleIndex].y = mousePos.y;

      while (index > 0) {
        index -= 1;
        selectedHandleIndex = selectedHandleIndexes[index];
        shape.points[selectedHandleIndex].x += deltaX;
        shape.points[selectedHandleIndex].y += deltaY;
      }
    } else if (currentTool === Tools.HAND && drag.active) {
      var zoomValue = parseInt(form.zoom.value);
      var gridDivisionValue = parseInt(form.grid.value);
      var amount = 1 / zoomValue * gridDivisionValue;
      panX = drag.panX + Math.floor((x - drag.x) * amount);
      panY = drag.panY + Math.floor((y - drag.y) * amount);
      grid.set(parseInt(zoomValue));
      redraw();
    } else if (currentTool === Tools.VISIBILITY) {
      var index = indexForPoint(mousePos);
      if (index === -1) {
        if (tempVisibility) clearTempVisibility(tempVisibility.state);
      } else {
        if ((tempVisibility && tempVisibility.index === index) || !canSetVisibilityForIndex(index, shape)) return;
        if (tempVisibility && tempVisibility.index !== index) clearTempVisibility(tempVisibility.state);
        var point = shape.points[index];
        tempVisibility = {
          index: index,
          state: point.visible,
          point: point,
        };

        var flashInterval = setInterval(function() {
          var point = tempVisibility.point;
          point.visible = !point.visible;
          redraw();
        }, 250);

        tempVisibility.stopFlashing = function() { clearInterval(flashInterval); };
      }
    }
};

var clearTempVisibility = function(visible) {
  tempVisibility.stopFlashing();
  tempVisibility.point.visible = visible;
  tempVisibility = undefined;
}

// Button
var buttonPencil = document.getElementById("pencil");
var buttonArrows = document.getElementById("arrows");
var buttonPlus = document.getElementById("plus");
var buttonScissors = document.getElementById("scissors");
var buttonCrosshairs = document.getElementById("crosshairs");
var buttonEyeSlash = document.getElementById("eye-slash");
var buttonAnchor = document.getElementById("anchor");
var buttonHand = document.getElementById("hand");
var buttonScale = document.getElementById("scale");

buttonPencil.onclick = function() {
    switchTool(Tools.LINE);
};
buttonArrows.onclick = function() {
    switchTool(Tools.MOVE);
};
buttonPlus.onclick = function() {
    switchTool(Tools.ADD);
};
buttonScissors.onclick = function() {
    switchTool(Tools.CUT);
};
buttonCrosshairs.onclick = function() {
    switchTool(Tools.ORIGIN);
};
buttonEyeSlash.onclick = function() {
    switchTool(Tools.VISIBILITY);
};
buttonAnchor.onclick = function() {
    snap_enabled = !snap_enabled;
    redraw();
};
buttonHand.onclick = function() {
    switchTool(Tools.HAND);
};
buttonHand.ondblclick = function() {
    panX = 0;
    panY = 0;
    drag.x = 0;
    drag.y = 0;
    drag.panX = 0;
    drag.panY = 0;
    drag.active = false;
    grid.set(parseInt(form.zoom.value));
    redraw();
};
buttonScale.onclick = function() {
  var scaleFactor = eval(prompt("Enter scale factor:", "1").replace(/[^\d\(\)\+\-\*\/%\.]/g, ''));
  if (!isNaN(scaleFactor)) {
    var points = JSON.parse('[' + text.value + ']');
    for (var i = 0, length = points.length; i < length; i++) {
      if (points[i] < PEN_UP) { points[i] *= scaleFactor; }
    }
    text.value = points;
    text.onchange();
  }
};
var color_index;
for(color_index = 1; color_index<=16; color_index++){
    (function (_color_index) {
        document.getElementById("color:" + _color_index).onclick = function() {
            switchTool(Tools.COLORIZE);
            current_selected_color = _color_index;
        };
    })(color_index);
}

document.getElementById("refresh").onclick = function() {
    if(confirm("Clear all frames and polygon points and start over? This operation cannot be undone.")){
        switchTool(Tools.LINE);
        text.value = '';
        shapes = [new Shape()];
        frame = 0;
        history[frame].clear();
        redraw();
    }
};
document.getElementById("undo").onclick = function() {
    undo();
};
document.getElementById("redo").onclick = function() {
    redo();
};

document.getElementById("prev-frame-visible").onclick = function() {
  previousFrameVisible = !previousFrameVisible;
  redraw();
};

document.getElementById("next-frame-visible").onclick = function() {
  nextFrameVisible = !nextFrameVisible;
  redraw();
};

var switchToPreviousFrame = function() {
  switchToFrame(frame - 1);
};

var switchToNextFrame = function() {
  switchToFrame(frame + 1);
};

var switchToFrame = function(newFrame) {
  if (newFrame < 0 || newFrame > shapes.length - 1) return;
  stopAnimation();
  frame = newFrame;
  redraw();
};

document.getElementById("back-button").onclick = switchToPreviousFrame;
document.getElementById("next-button").onclick = switchToNextFrame;

document.getElementById("add-button").onclick = function() {
  stopAnimation();
  var previousHistory = history[frame];
  frame += 1;
  shapes.splice(frame, 0, new Shape());
  var newHistory = new History();
  newHistory.copy(previousHistory);
  history.splice(frame, 0, newHistory);
  redraw();
};

document.getElementById("delete-button").onclick = function() {
  stopAnimation();
  if (frame === 0) return;
  shapes.splice(frame, 1);
  history.splice(frame, 1);
  if (frame > shapes.length - 1) frame -= 1;
  redraw();
};

document.getElementById("clipboard-button").onclick = function() {
  var currentGridDivisionValue = gridDivision.value;
  gridDivision.value = 1;
  gridDivision.onchange();
  var frames = getAllFrames();
  form.frames.value = JSON.stringify(frames);
  form.frames.select();
  if (document.execCommand('copy')) {
    alert('copied ' + shapes.length + ' frames to clipboard!')
  }
  gridDivision.value = currentGridDivisionValue;
  gridDivision.onchange();
};

var interval;
var currentSpeed;
var animate = function() {
  if (interval || shapes.length <= 1) return;
  currentSpeed = 1000 - (parseInt(speed.value) || 0);
  interval = setInterval(function() {
    frame += 1;
    if (frame >= shapes.length) frame = 0;
    redraw();
  }, currentSpeed);
};
var stopAnimation = function() {
  if (typeof(interval) !== undefined) clearInterval(interval);
  interval = undefined;
  redraw();
};
var restartAnimation = function() {
  if (!interval || currentSpeed === (parseInt(speed.value, 10) || 0)) return;
  stopAnimation();
  animate();
};

var updateGridFraction = function() {
  var tool = currentTool;
  gridDivisionValue = parseInt(gridDivision.value);
  gridFraction = 1 / gridDivisionValue;
  grid.set(parseInt(form.zoom.value));
  var modifier = gridDivisionValue * lastGridFraction;
  var frames = getAllFrames({ modifier : modifier });
  if (shapes.length > 1) {
    var currentFrame = frame;
    for (var i = 0, length = frames.length; i < length; i++) {
      if (i === currentFrame) continue;
      text.value = frames[i].join(DELIMITER);
      frame = i;
      currentShape().reset();
    }
    frame = currentFrame;
    text.value = (frames[frame] || []).join(DELIMITER);
  } else {
    text.value = frames.join(DELIMITER);
  }
  currentShape().reset();
  lastGridFraction = gridFraction;
  switchTool(tool);
};

document.getElementById("play-button").onclick = animate;
document.getElementById("stop-button").onclick = stopAnimation;

speed.onchange = restartAnimation;
speed.oninput  = restartAnimation;

gridDivision.onchange = updateGridFraction;
gridDivision.oninput  = updateGridFraction;

// Keyboard handler
document.addEventListener("keydown", function(evt) {
  if (document.activeElement === text || evt.metaKey) return;
    switch(evt.keyCode){
        case 77: // "M"
        case 27: // <escape>
            switchTool(Tools.MOVE);
            break;
        case 76: // "L"
            switchTool(Tools.LINE);
            break;
        case 72: // "H"
            switchTool(Tools.HAND);
            break;
        case 65: // "A"
            switchTool(Tools.ADD);
            break;
        case 67: // "C"
            switchTool(Tools.CUT);
            break;
        case 79: // "O"
            switchTool(Tools.ORIGIN);
            break;
        case 86: // "V"
            switchTool(Tools.VISIBILITY);
            break;
        case 85: // "U"
            undo();
            break;
        case 82: // "R"
            redo();
            break;
        case 83: // "S"
            snap_enabled = !snap_enabled;
            redraw();
            break;
        case 88:
            buttonScale.onclick();
            break;
        case 37:
            if (evt.shiftKey) {
              switchToFrame(0);
            } else {
              switchToPreviousFrame();
            }
            break;
        case 39:
            if (evt.shiftKey) {
              switchToFrame(shapes.length - 1);
            } else {
              switchToNextFrame();
            }
            break;
    }
});

var urlParam = window.location.search.substring(1);
if (urlParam.length) {
  text.value = urlParam;
  text.onchange();
}
switchTool(Tools.LINE);

}).call();

</script>
</body>
</html>
